## @file views.py
# @author Stephen Longofono
# @brief Manages login, session, and server-side interaction of project pages
#
# @details
# 	This file defines all the viable addresses for our project webpages and how
# they will interact on the server side.  After directing visitors through a login
# process, a session is established to preserve the state of a calendar object.
# Based on the contents of a logfile, a calendar object is instantiated and assigned
# as a member of a session (cookie-like object).
#
#	Each method is marked with a decorator, indicating that Flask should call that
# method when the address argument of app.route() is accessed by the user.  Most methods
# handle the control of what the user can and cannot see or otherwise access.  The process
# method interacts with client-side Javascript to parse and interpret input.  Javascript is
# able to access objects passed into the render_template() method, and responds to the server
# via JSON.
#

from app import app					#import our configured app from upstream
from flask import render_template	#ability to use jinja2 templates
from flask import flash				#ability to pass consumeable (client-side feedback)
from flask import redirect			#ability to override browser address request
from flask import session			#cookies to track the calendar for session
from flask import url_for			#let flask manage urls, we use function names
from forms import LoginForm			#import custom definition defined in forms.py
from forms import DateForm			#import custom date form
from flask import request			#Allow access to HTTP requests
from flask import json				#Prepare responses to requests for client
from flask import logging			#Developer feedback
import Calendar						#Our calendar class

## @fn index
# @brief root domain request behavior
# @param [in]  session An implicit variable generated by flask, acts as a cryptographically signed cookie to store any information which should be preserved across requests
# @param [out] return A rendered HTML document representing the current state of the calendar
#
# @details
#
# The root will always check that a session has been established for the user.
# Failure to meet this condition will redirect the user to the login() method.
# If the calendar does not already exist, it is built from the logfile.  The user
# is directed to the appropriate page template based on the calendar's display mode.
#
@app.route('/')
@app.route('/index')
@app.route('/index/<string:view>')
def index(view=None):
	if 'uname' in session:
		# if logged in...
		# Check if we already made a calendar for the user
		if not 'calendar' in session:
			# TODO add code to instantiate a calendar object
			#session['calendar'] = init_calendar()
			calendar = Calendar.Calendar('2016', '2017')
			print calendar.currentDay().weekday
			print calendar.currentDay().month
			print calendar.currentDay().date
			print calendar.currentDay().month.year.name
			session['calendar'] = calendar
			session['displayDefault'] = 'day'

			flash(session['calendar'])
			# Render the day template page by default
			return render_template('day.html',
									weekDay=session['calendar'].currentDay().day,
									date=session['calendar'].currentDay().date,
									month=session['calendar'].currentMonth(),
									year=session['calendar'].currentDay().year,
									user=session['uname'])

		else:
			# We have a calendar, render the appropriate template
			flash(session['calendar'])

			# Give precedence to directly specified view, which should
			# always match the current displayMode in calendar
			display = view or session['displayDefault']

			if 'week' == display:
				flash('rendering week view')
				return render_template('week.html',
										week=session['calendar'].getWeek(),
										user=session['uname'])

			elif 'month' == display:
				flash('rendering month view')
				return render_template('month.html',
										month=session['calendar'].getMonth().name,
										days=session['calendar']getMonth().days,
										user=session['uname'])

			elif 'year' == display:
				flash('rendering year view')
				return render_template('year.html', calendar=session['calendar'], user=session['uname'])

			flash('rendering day view')
			app.logger.info(session['calendar'])
			return render_template('day.html', calendar=session['calendar'], user=session['uname'])

	# User hasn't logged in yet, provide feedback
	flash('You must log in to see this page')
	return redirect(url_for('login'))

## @fn login
# @brief login request behavior
# @param [in]  session An implicit variable generated by flask, acts as a cryptographically signed cookie to store any information which should be preserved across requests
# @param [out] return Redirects to the index() method, or A rendered HTML document of the login page if the login credentials are invalid
#
# @details
#
# The login will validate the user's input using a LoginForm and create a session for the user if the
# credentials are valid.  The user and session are then redirected to the index() method.  If the user
# credentials are invalid, the login page is re-rendered and feedback is provided.
#
@app.route('/login', methods=['GET', 'POST'])
def login():

	form = LoginForm()
	if form.validate_on_submit():	#if all our validation checks pass
		if form.uname.data == app.config['USERNAME'] and form.pword.data == app.config['PASSWORD']:
			# Send up a feedback message
			flash('%s was logged in' % ( form.uname.data ))
			user = {'name':form.uname.data}
			# Prepare a session to hold user info and the calendar objects
			session['uname'] = form.uname.data
			flash('session prepared')
			# Go to main page with populated session
			return redirect(url_for('index'))

	# bad login, provide feedback
	flash('invalid username or password')
	return render_template('login.html', title='Sign In', form=form)

## @fn logout
# @brief logout request behavior
# @param [in]  session An implicit variable generated by flask, acts as a cryptographically signed cookie to store any information which should be preserved across requests
# @param [out] return Redirects to the login() method
#
# @details
#
# The logout will clear all data from the session field, and redirect to the login() method
#
@app.route('/logout')
def logout():
	session.clear()
	return redirect(url_for('login'))

@app.route('/process', methods=['POST'])
def process():
	try:
		# Create a new details list
		newDetails = []
		# Add any JSON members with a name that begins with 'detail'
		for a,b in request.form.iteritems():
			if a.startsith('detail'):
				newDetails.append(b)

		#TODO add code to Update log file

	except:
		# Error state, return bad status
		return json.dumps({'status':'BAD'})

	# If all is well, replace existing details with new ones and return OK
	session['calendar'].currentDay().details = newDetails
	return json.dumps({'status':'OK'})

@app.route('/viewChange', methods=['POST'])
def viewChange():

	# Case the next day button clicked from day view
	if request.form['view'] == 'next':
		flash('changing current day to next day')

		# Change current day to the following day
		session['calendar'].currentDay = session['calendar'].currentDay().getNext()
		result = {'status':'OK', 'link':url_for('index', view='day')}

	# Case the previous day button clicked from day view
	elif request.form['view'] == 'prev':
		flash('changing current day to previous day')

		# TODO add code to change current day to the next day
		session['calendar'].currentDay = session['calendar']['currentDay'].getPrev()
		result = {'status':'OK', 'link':url_for('index')}

	else:

		flash('changing view to : ' + request.form['view'])

		if request.form['view'] == 'day':
			result = {'status':'OK', 'link':url_for('index', view='day')}
		elif request.form['view'] == 'week':
			result = {'status':'OK', 'link':url_for('index',view='week')}
		elif request.form['view'] == 'month':
			result = {'status':'OK', 'link':url_for('index',view='month')}
		else:
			result = {'status':'OK', 'link':url_for('index',view='year')}
		#session['calendar']['displayMode'] = request.form['view']
	# Prepare a JSON response with a link for root
	print 'Returning: ', result
	return json.dumps(result)
