## @file views.py
# @author Stephen Longofono
# @brief Manages login, session, and server-side interaction of project pages
#
# @details
# 	This file defines all the viable addresses for our project webpages and how
# they will interact on the server side.  After directing visitors through a login
# process, a session is established to preserve the state of a calendar object.
# Based on the contents of a logfile, a calendar object is instantiated and assigned
# as a member of a session (cookie-like object).
#
#	Each method is marked with a decorator, indicating that Flask should call that
# method when the address argument of app.route() is accessed by the user.  Most methods
# handle the control of what the user can and cannot see or otherwise access.  The process
# method interacts with client-side Javascript to parse and interpret input.  Javascript is
# able to access objects passed into the render_template() method, and responds to the server
# via JSON.
#

from app import app			#import our configured app from upstream
from flask import render_template	#ability to use jinja2 templates
from flask import flash			#ability to pass consumeable text content
from flask import redirect		#ability to override browser address request
from flask import session		#cookies to track the calendar for session
from flask import url_for		#let flask manage urls, we use function names
from forms import LoginForm		#import custom definition defined in forms.py
from forms import DateForm		#import custom date form
from flask import request		#Allow access to HTTP requests
from flask import json			#Prepare responses to requests for client
from flask import logging		#Developer feedback
from jinja2.ext import autoescape #sanitize on client-side

## @fn index
# @brief root domain request behavior
# @param [in]  session An implicit variable generated by flask, acts as a cryptographically signed cookie to store any information which should be preserved across requests
# @param [out] return A rendered HTML document representing the current state of the calendar
#
# @details
#
# The root will always check that a session has been established for the user.
# Failure to meet this condition will redirect the user to the login() method.
# If the calendar does not already exist, it is built from the logfile.  The user
# is directed to the appropriate page template based on the calendar's display mode.
#
@app.route('/')
@app.route('/index')
def index():
	if 'uname' in session:
		# if logged in...
		# Check if we already made a calendar for the user
		if not 'calendar' in session:
			# Instantiate a calendar object
			#session['calendar'] = init_calendar()
			calendar = {}
			calendar['currentDay'] = {}
			calendar['currentDay']['day'] = 'Saturday'
			calendar['currentDay']['date'] = '10'
			calendar['currentDay']['month'] = 'September'
			calendar['currentDay']['details'] = []
			calendar['currentDay']['details'].append('No class: EECS448')
			calendar['currentDay']['details'].append('EECS645 Homework due')
			calendar['currentDay']['details'].append('Go see the dude about the thing')
			calendar['name'] = '2016'
			calendar['months'] = []
			calendar['months'].append('january')
			calendar['displayMode'] = 'day'
			session['calendar'] = calendar

			# Render the day template page
			return render_template('day.html', calendar=session['calendar'], user=session['uname'])

		else:
			flash('calendar was found, rendering from main')
			# We have a calendar, render the appropriate template
			# for the calendar's display mode
			if 'day' == session['calendar']['displayMode']:
				return render_template('day.html', calendar=session['calendar'], user=session['uname'])

			elif 'week' == session['calendar'].displayMode:
				return render_template('week.html', calendar=session['calendar'])

			elif 'month' == session['calendar'].displayMode:
				return render_template('month.html', calendar=session['calendar'])

			return render_template('year.html', calendar=session['calendar'])

	# User hasn't logged in yet, provide feedback
	flash('You must log in to see this page')
	return redirect(url_for('login'))

## @fn login
# @brief login request behavior
# @param [in]  session An implicit variable generated by flask, acts as a cryptographically signed cookie to store any information which should be preserved across requests
# @param [out] return Redirects to the index() method, or A rendered HTML document of the login page if the login credentials are invalid
#
# @details
#
# The login will validate the user's input using a LoginForm and create a session for the user if the
# credentials are valid.  The user and session are then redirected to the index() method.  If the user
# credentials are invalid, the login page is re-rendered and feedback is provided.
#
@app.route('/login', methods=['GET', 'POST'])
def login():

	form = LoginForm()
	if form.validate_on_submit():	#if all our validation checks pass
		if form.uname.data == app.config['USERNAME'] and form.pword.data == app.config['PASSWORD']:
			# Send up a feedback message
			flash('%s was logged in' % ( form.uname.data ))
			user = {'name':form.uname.data}
			# Prepare a session to hold user info and the calendar objects
			session['uname'] = form.uname.data
			flash('session prepared')
			# Go to main page with populated session
			return redirect(url_for('index'))

	# bad login, provide feedback
	flash('invalid username or password')
	return render_template('login.html', title='Sign In', form=form)

## @fn logout
# @brief logout request behavior
# @param [in]  session An implicit variable generated by flask, acts as a cryptographically signed cookie to store any information which should be preserved across requests
# @param [out] return Redirects to the login() method
#
# @details
#
# The logout will clear all data from the session field, and redirect to the login() method
#
@app.route('/logout')
def logout():
	session.clear()
	return redirect(url_for('login'))

@app.route('/process', methods=['POST'])
def process():
	for a,b in request.form.iteritems():
		app.logger.info(a + ': ' + b)

	found = True
	#Find the day and update

	if not found:
		return json.dumps({'status':'BAD'})

	return json.dumps({'status':'OK'})

@app.route('/viewChange', methods=['POST'])
def viewChange():
	if request.form['view'] == 'next':
		session['calendar']['currentDay'] = session['calendar']['currentDay'].getNext()
	elif request.form['view'] == 'prev':
		session['calendar']['currentDay'] = session['calendar']['currentDay'].getPrev()
	else:
		session['calendar']['displayMode'] = request.form['view']
	return json.dumps('OK')
