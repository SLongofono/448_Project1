## @file views.py
# @author Stephen Longofono
# @brief Manages login, session, and server-side interaction of project pages
#
# @details
# 	This file defines all the viable addresses for our project webpages and how
# they will interact on the server side.  After directing visitors through a login
# process, a session is established to preserve the state of a calendar object.
# Based on the contents of a logfile, a calendar object is instantiated and assigned
# as a member of a session (cookie-like object).
#
#	Each method is marked with a decorator, indicating that Flask should call that
# method when the address argument of app.route() is accessed by the user.  Most methods
# handle the control of what the user can and cannot see or otherwise access.  The process
# method interacts with client-side Javascript to parse and interpret input.  Javascript is
# able to access objects passed into the render_template() method, and responds to the server
# via JSON.
#

from app import app					# Import our configured app object from upstream
from flask import render_template	# Ability to use jinja2 templates
from flask import flash				# Ability to pass consumeable text content
from flask import redirect			# Ability to override browser address request
from flask import session			# Cookies to track the calendar for session
from flask import url_for			# Let flask manage urls, we use function names
from forms import LoginForm			# Import custom definition defined in forms.py
from forms import DateForm			# Import custom date form
from flask import request			# Allow access to HTTP requests
from flask import json				# Prepare responses to requests for client
from flask import logging			# Developer feedback
import Calendar

calendar_obj	= Calendar.Calendar(2016, 2017)
app.logger.info('TESTING CALENDAR GLOBAL')
app.logger.info(calendar_obj.year1.name)
app.logger.info(calendar_obj.year2.name)
app.logger.info(calendar_obj.currentDay)
app.logger.info(calendar_obj.currentWeek)
app.logger.info(calendar_obj.getCurrentWeek)
app.logger.info(calendar_obj.getCurrentYear)

calendar_obj.currentDay.addDetail('PHSX Lab 2PM')
calendar_obj.currentDay.addDetail('Meeting with advisor 4PM')
calendar_obj.currentDay.addDetail('Party 8PM')
## @fn index
# @brief root domain request behavior
# @param [in]  session An implicit variable generated by flask, acts as a cryptographically signed cookie to store any information which should be preserved across requests
# @param [out] return A rendered HTML document representing the current state of the calendar
#
# @details
#
# The root will always check that a session has been established for the user.
# Failure to meet this condition will redirect the user to the login() method.
# If the calendar does not already exist, it is built from the logfile.  The user
# is directed to the appropriate page template based on the calendar's display mode.
#

@app.route('/')
@app.route('/index')
@app.route('/index/<string:view>')
def index(view=None):
	if 'uname' in session:
		# if logged in...

		# Give precedence to directly specified view
		display = view or 'day'
		year  = calendar_obj.getCurrentYear().name
		month = calendar_obj.getCurrentMonth().name
		weekday = calendar_obj.currentDay.weekday

		if 'week' == display:
			flash('rendering week view')
			daysList = [str(x.date) for x in calendar_obj.currentWeek]
			return render_template('week.html',
									days=daysList,
									dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
									month=month,
									year=year,
									user=session['uname'])

		elif 'month' == display:
			flash('rendering month view')
			weekday = calendar_obj.getCurrentMonth().days[0].weekday
			numDays = len(calendar_obj.getCurrentMonth().days)
			weeks = []
			for week in calendar_obj.getCurrentMonth().weeks:
				weeks.append([str(x.date) for x in week])
			return render_template('month.html',
									weeks=weeks,
									weekday=weekday,
									month=month,
									year=year,
									user=session['uname'])

#				return render_template('month.html', calendar=calendar_obj, user=session['uname'])

		elif 'year' == display:
			flash('rendering year view')
			return render_template('year.html',
									year=year,
									user=session['uname'])

		flash('rendering day view')
		weekday = calendar_obj.getCurrentDay().weekday
		date = calendar_obj.getCurrentDay().date
		details = list(calendar_obj.getCurrentDay().details)
		app.logger.info(details)
		return render_template('day.html',
								weekday=weekday,
								date=date,
								details=details,
								month=month,
								year=year,
								user=session['uname'])

	# User hasn't logged in yet, provide feedback
	flash('You must log in to see this page')
	return redirect(url_for('login'))

## @fn login
# @brief login request behavior
# @param [in]  session An implicit variable generated by flask, acts as a cryptographically signed cookie to store any information which should be preserved across requests
# @param [out] return Redirects to the index() method, or A rendered HTML document of the login page if the login credentials are invalid
#
# @details
#
# The login will validate the user's input using a LoginForm and create a session for the user if the
# credentials are valid.  The user and session are then redirected to the index() method.  If the user
# credentials are invalid, the login page is re-rendered and feedback is provided.
#
@app.route('/login', methods=['GET', 'POST'])
def login():

	form = LoginForm()
	if form.validate_on_submit():	#if all our validation checks pass
		if form.uname.data == app.config['USERNAME'] and form.pword.data == app.config['PASSWORD']:
			# Send up a feedback message
			flash('%s was logged in' % ( form.uname.data ))
			user = {'name':form.uname.data}
			# Prepare a session to hold user info and the calendar objects
			session['uname'] = form.uname.data
			flash('session prepared')
			# Go to main page with populated session
			return redirect(url_for('index'))

	# bad login, provide feedback
	flash('invalid username or password')
	return render_template('login.html', title='Sign In', form=form)

## @fn logout
# @brief logout request behavior
# @param [in]  session An implicit variable generated by flask, acts as a cryptographically signed cookie to store any information which should be preserved across requests
# @param [out] return Redirects to the login() method
#
# @details
#
# The logout will clear all data from the session field, and redirect to the login() method
#
@app.route('/logout')
def logout():
	session.clear()
	return redirect(url_for('login'))

@app.route('/process', methods=['POST'])
def process():
	for a,b in request.form.iteritems():
		app.logger.info(a + ': ' + b)

	found = True
	#Find the day and update

	#Update log file

	#return status
	if not found:
		return json.dumps({'status':'BAD'})

	return json.dumps({'status':'OK'})

@app.route('/viewChange', methods=['POST'])
def viewChange():
	if request.form['view'] == 'next':
		flash('changing current day to next day')
		calendar_obj.currentDay = calendar_obj.getCurrentDay().getNext()
		result = {'status':'OK', 'link':url_for('index')}
	elif request.form['view'] == 'prev':
		flash('changing current day to previous day')
		calendar_obj.currentDay = calendar_obj.getCurrentDay().getPrev()
		result = {'status':'OK', 'link':url_for('index')}
	else:
		flash('changing view to : ' + request.form['view'])
		print session
		print calendar_obj
		if request.form['view'] == 'day':
			result = {'status':'OK', 'link':url_for('index', view='day')}
		elif request.form['view'] == 'week':
			result = {'status':'OK', 'link':url_for('index',view='week')}
		elif request.form['view'] == 'month':
			result = {'status':'OK', 'link':url_for('index',view='month')}
		else:
			result = {'status':'OK', 'link':url_for('index',view='year')}

	# Prepare a JSON response with a link for root
	app.logger.info('Returning: ')
	app.logger.info(result)
	return json.dumps(result)

@app.route('/changeFocusDay', methods=['POST'])
def changeFocusDay():
	day = int(request.form['day'])
	month = request.form['month']
	year = int(request.form['year'])
	# Find the new focus day and update current day, week, month, year
	calendar_obj.currentMonth = calendar_obj.getMonth(month, year)
	calendar_obj.currentDay = calendar_obj.getDay(day-1)
	if calendar_obj.currentMonth.year == calendar_obj.year1.name:
		calendar_obj.currentYear = calendar_obj.year1
	else:
		calendar_obj.currentYear = calendar_obj.year2
	calendar_obj.currentWeek = calendar_obj.getCurrentWeek()

	# render the day view with the new day
	return redirect(url_for('index', view='day'))

@app.route('/changeFocusWeek', methods=['POST'])
def changeFocusWeek():
	month = request.form['month']
	year = int(request.form['year'])
	weekNum = int(request.form['weekNum'])
	calendar_obj.currentMonth = calendar_obj.getMonth(month, year)
	calendar_obj.currentWeek = calendar_obj.currentMonth.weeks[weekNum]
	calendar_obj.currentDay = calendar_obj.currentWeek[0]
	if calendar_obj.currentMonth.year == calendar_obj.year1.name:
		calendar_obj.currentYear = calendar_obj.year1
	else:
		calendar_obj.currentYear = calendar_obj.year2

	# render the week view with the new week
	return redirect(url_for('index', view='week'))

@app.route('/changeFocusMonth', methods=['POST'])
def changeFocusMonth():
	month = request.form['month']
	year = int(request.form['year'])
	calendar_obj.currentMonth = calendar_obj.getMonth(month, year)
	calendar_obj.currentWeek = calendar_obj.currentMonth.weeks[0]
	calendar_obj.currentDay = calendar_obj.currentWeek[0]
	if calendar_obj.currentMonth.year == calendar_obj.year1.name:
		calendar_obj.currentYear = calendar_obj.year1
	else:
		calendar_obj.currentYear = calendar_obj.year2

	# render the month view with the new month
	return redirect(url_for('index', view='month'))

@app.route('/changeFocusYear', methods=['POST'])
def changeFocusYear():
	year = int(request.form['year'])
	if calendar_obj.year1.name == year:
		calendar_obj.currentYear = calendar_obj.year1
	else:
		calendar_obj.currentYear = calendar_obj.year2

	calendar_obj.currentMonth = calendar_obj.currentYear.months[0]
	calendar_obj.currentWeek = calendar_obj.currentMonth.weeks[0]
	calendar_obj.currentDay = calendar_obj.currentWeek[0]

	# render the year view with the new year
	return redirect(url_for('index', view='year'))
